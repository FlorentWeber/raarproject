annex_file



//***************************************************
//******       The Main program                ******
//***************************************************



syntactic_rule C_MPI is
begin
    put_line ('/*');
    put_line ('##=======================================================================');
    put_line ('##Copyright (C) 2007-2008 C_MPI Generator');
    put_line ('##This program is free software; you can redistribute it and/or modify');
    put_line ('##it under the terms of the GNU General Public License (GPL) as published');
    put_line ('##of the License, or (at your option) any later version.');
    put_line ('##');
    put_line ('##This program is distributed in the hope that it will be useful,');
    put_line ('##but WITHOUT ANY WARRANTY; without even the implied warranty of');
    put_line ('##MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the');
    put_line ('##GNU General Public License for more details.');
    put_line ('##');
    put_line ('##To read the license please visit http://www.gnu.org/copyleft/gpl.html');
    put_line ('##=======================================================================');
    put_line ('##');
    put_line ('## File          : hello.c');
    put_line ('## Authors       : Leonardo BAUTISTA GOMEZ <leobago@gmail.com>');
    put_line ('##               : Florent WEBER <florent.weber@gmail.com>');
    put_line ('##               : Julien CLEMENT <julien.jclement@gmail.com>');
    put_line ('##               : Felix MACH <felix.mach@gmail.com>');
    put_line ('##               : Henry LAY <lay.henri83@gmail.com>');
    put_line ('##               : Remi VILLE <raymooz@gmail.com>');
    put_line ('##               : Shi-Hon CHAN <syone7@gmail.com>');
    put_line ('##');
    put_line ('##');
    put_line ('*/');
    new_line(1);
    put_line ('#include <math.h>');
    put_line ('#include <stdio.h>');
    put_line ('#include <unistd.h>');
    put_line ('#include <string.h>');
    put_line ('#include <mpi.h>');
    new_line (1);
    put_line ('#define TAG_END 0');
    put_line ('#define TAG_COMMP_PUT 1');
    put_line ('#define TAG_COMMP_GET 2');
    put_line ('#define TAG_SYNCT_ASK 3');
    put_line ('#define TAG_SYNCT_ACK 4');
    new_line (1);
    put_line ('#define EXEC_DURATION 30');
    put_line ('#define EXEC_STEP 1');
    new_line (1);
    put_line ('#define PROTO_MANAGER 0');
    put_line ('#define SYNCT_MANAGER 1');
    put_line ('#define COMMP_MANAGER 2');
    new_line (1);


    //Declare the global enum for local places
    apply GLOBAL_LIST_ELEMENTS($0) ;
    new_line (1);

    //Declare the global enum for communication places
    apply GLOBAL_LIST_COMM_PLACE($0) ;
    new_line (1);

    //Declare the global enum for sync transitions
    apply GLOBAL_LIST_SYNC_TRANS($0) ;
    new_line (1);

    //Calling the LIST_PROCESS syntactic rule
    apply($1);
    new_line (1);

	apply INIT_LIST_COMM_PLACE ($3) ;
	new_line (1);

	apply INIT_LIST_SYNC_TRANS ($2) ;
	new_line (1);

    // Declare instanceArray global var
    apply GLOBAL_LIST_INSTANCE ($4) ;

    new_line (1);
    put_line ('int main (int argc, char** argv) {');
    new_line (1);
    increase_marging;
    put_line ('int i, my_rank, nb_proc;');
    new_line (1);

    // Instanciate the instanceArray global var
    apply ($4) ;

    new_line (1);
    put_line ('MPI_Request request;');
    new_line (1);
    put_line ('MPI_Init(&argc, &argv);');
    put_line ('MPI_Comm_rank(MPI_COMM_WORLD, &my_rank);');
    put_line ('MPI_Comm_size(MPI_COMM_WORLD, &nb_proc);');
    new_line (1);
    put_line ('//The prototype manager');
    put_line ('if (my_rank == 0) {');
    increase_marging;
    put_line ('printf(" My rank is %d and I am the prototype manager\n",my_rank);');
    new_line (1);
    put_line ('//Sleeping EXEC_DURATION seconds');
    put_line ('sleep(EXEC_DURATION);');
    new_line (1);
    put_line ('//Killing all the process');
    put_line ('for(i = 1; i < nb_proc; i++) {');
    increase_marging;
    put_line('int buf = 0;');
    put_line ('MPI_Isend(&buf,1,MPI_INT,i,TAG_END,MPI_COMM_WORLD,&request);');
    put_line ('printf(" My rank is %d and I am sending END to %d\n",my_rank,i);');
    decrease_marging;
    put_line ('}');
    put_line ('MPI_Barrier(MPI_COMM_WORLD);');
    decrease_marging;
    put_line ('}');
    new_line (2);

    //Calling the LIST_SYNC_TRANS syntactic rule
    apply($2);

    //Calling the LIST_COMM_PLACE syntactic rule
    apply($3);
    new_line (1);

    put_line ('// Launching each PNProcess instance') ;
    put_line ('if (my_rank > 2) {') ;
    increase_marging;
    put_line ('instanceArray[my_rank-3]->code(instanceArray[my_rank-3]->startState, my_rank, nb_proc) ;') ;
    decrease_marging;
    put_line ('}') ;

    new_line (1);
    put_line ('if (my_rank != 0) {');
    increase_marging;
    put_line ('MPI_Barrier(MPI_COMM_WORLD);');
    decrease_marging;
    put_line ('}');

    new_line(1);
    // Free the instanceArray global var
    apply GLOBAL_FREE_LIST_INSTANCE ($4) ;
    new_line(1);

    put_line ('MPI_Finalize();');
    put_line ('return 0;');
    decrease_marging;
    put_line ('}');
end;



//***************************************************
//******       List of elements                ******
//***************************************************



syntactic_rule GLOBAL_LIST_ELEMENTS is
begin
    new_line(1) ;
    put_line ('// Global enum for each pn-process element') ;
    put ('enum ELEMENTS_T { ') ;
    apply INTERNAL_GLOBAL_LIST_ELEMENTS($1) ;
    apply INTERNAL_GLOBAL_LIST_SYNC_TRANS($2) ;
    put_line (' } ;') ;
    new_line(1) ;
end;


syntactic_rule INTERNAL_GLOBAL_LIST_SYNC_TRANS is
begin

	if $# > 0 then
		put(',');
		put ('__') ;
		put_upper ($STR(1)) ;

		if $# > 1 then
			apply INTERNAL_GLOBAL_LIST_SYNC_TRANS ($2*);
		end if;
	end if;

end ;


syntactic_rule INTERNAL_GLOBAL_LIST_ELEMENTS is
begin
    apply INTERNAL_PROCESS_PLACES($1) ;
    put(',');
    apply INTERNAL_PROCESS_TRANSITIONS($1) ;

    if $# > 1 then
        put(',');
    	apply INTERNAL_GLOBAL_LIST_ELEMENTS ($2*);
    end if;
end;


syntactic_rule INTERNAL_PROCESS_TRANSITIONS is
begin
    apply LOCAL_TRANSITIONS ($2) ;
end;


syntactic_rule INTERNAL_PROCESS_PLACES is
begin
    apply LOCAL_PLACES($1) ;
end;



//***************************************************
//******       Synchronisation transitions      ******
//***************************************************

syntactic_rule GLOBAL_LIST_SYNC_TRANS is
begin
	new_line(1) ;

	put_line ('enum SYNC_TRANS_T {') ;
	apply GLOBAL_ENUM_SYNC_TRANS ($2) ;
	new_line(1) ;
	put_line ('} ;') ;

end ;

syntactic_rule GLOBAL_ENUM_SYNC_TRANS is
begin
	if $# > 0 then

		put ('__ST_') ;
		put_upper ($STR(1));

		if $# > 1 then
			put (',') ;

			apply GLOBAL_ENUM_SYNC_TRANS ($2*);
		end if;

	else
		put ('__NO_ST');
	end if;
end ;

syntactic_rule INIT_LIST_SYNC_TRANS is
begin

	put_line('void syncTransMngr (int my_rank, int nb_proc)') ;
	put_line('{') ;
	increase_marging;
	put_line ('MPI_Status status;');
	put_line('int buf;');
	new_line(1) ;
	put_line('printf(" My rank is %d and I am the synchronisation transitions manager\n",my_rank);');
	new_line(1) ;
	put_line('while (1) {') ;
	increase_marging;
	put_line('MPI_Recv(&buf,1,MPI_INT,MPI_ANY_SOURCE,MPI_ANY_TAG,MPI_COMM_WORLD,&status);');
	put_line('if (status.MPI_SOURCE == PROTO_MANAGER) break ;') ;
	new_line(1) ;

        if $# > 0 then
            apply INTERNAL_LIST_SYNC_TRANS ($0);
        end if;

	decrease_marging;
	put_line('}') ;
	decrease_marging;
	put_line('}') ;
	new_line(1) ;

end ;

syntactic_rule LIST_SYNC_TRANS is
begin
    put ('//There are ');
    put ($STR_INT (0));
    put_line (' synchronisation transitions');
    put_line('if (my_rank == SYNCT_MANAGER) {');
    increase_marging;
    put_line('syncTransMngr(my_rank, nb_proc) ;') ;
    decrease_marging;
    put_line('}');
    new_line(2);
end;


syntactic_rule INTERNAL_LIST_SYNC_TRANS is
    begin
    put ('//Synchronisation transition ');
    apply ($1);
    put ('!');
    new_line(1);
    if $# > 1 then
        apply INTERNAL_LIST_SYNC_TRANS ($2*);
    end if;
end;



//***************************************************
//******       Communication places            ******
//***************************************************

syntactic_rule GLOBAL_LIST_COMM_PLACE is
begin

	new_line(1);

	put_line ('typedef struct COMM_PLACE_T {') ;
	increase_marging;
	put_line ('struct CP_QUEUE_NODE_T * queue ;') ;
	put_line ('int count ;') ;
	decrease_marging;
	put_line ('} COMM_PLACE ;') ;

	new_line(1);

	put_line ('typedef struct CP_QUEUE_NODE_T {') ;
	increase_marging;
	put_line ('struct CP_QUEUE_NODE_T * next ;') ;
	put_line ('int rank ;') ;
	put_line ('int nbToken ;') ;
	decrease_marging;
	put_line ('} CP_QUEUE_NODE ;') ;

	new_line(1);

	put_line ('enum COMM_PLACES_TAG_T {') ;
	increase_marging;

	apply HEAD_TAG_ENUM_COMM_PLACE($3) ;
	new_line(1);
	decrease_marging;
	put_line ('} ;') ;

	put_line ('enum COMM_PLACES_T {') ;
	increase_marging;

	apply HEAD_ENUM_COMM_PLACE($3) ;
	new_line(1);
	decrease_marging;
	put_line ('} ;') ;

	new_line(2);

	put_line ('void appendToQueue (CP_QUEUE_NODE ** pqueue, int rank, int nbToken)') ;
	put_line ('{') ;
	increase_marging;
	put_line ('if (!(*pqueue))') ;
	put_line ('{') ;
	increase_marging;
	put_line ('*pqueue = (CP_QUEUE_NODE *) malloc(sizeof(CP_QUEUE_NODE)) ;') ;
	put_line ('(*pqueue)->next = NULL ;') ;
	put_line ('(*pqueue)->rank = rank ;') ;
	put_line ('(*pqueue)->nbToken = nbToken ;') ;
	put_line ('return ;') ;
	decrease_marging;
	put_line ('}') ;
	new_line(1) ;
	put_line ('CP_QUEUE_NODE * tmp = *pqueue ;') ;
	new_line(1) ;
	put_line ('while (tmp->next) tmp = tmp->next ;') ;
	new_line(1) ;
	put_line ('tmp->next = (CP_QUEUE_NODE *) malloc(sizeof(CP_QUEUE_NODE)) ;') ;
	put_line ('tmp->next->next = NULL ;') ;
	put_line ('tmp->next->rank = rank ;') ;
	put_line ('tmp->next->nbToken = nbToken ;') ;
	put_line ('printf("Added a process to queue, nbToken=%d, rank=%d\n", nbToken, rank) ;') ;
	decrease_marging;
	put_line ('}') ;

	new_line(1) ;

	put_line ('CP_QUEUE_NODE * popFromQueue(CP_QUEUE_NODE ** pqueue)') ;
	put_line ('{') ;
	increase_marging;
	put_line ('if (!(*pqueue)) return NULL ;') ;
	new_line(1) ;
	put_line ('CP_QUEUE_NODE * tmp = *pqueue ;') ;
	new_line(1) ;
	put_line ('*pqueue = (*pqueue)->next ;') ;
	put_line ('printf("Popped a process from queue, nbToken=%d, rank=%d\n", tmp->nbToken, tmp->rank) ;') ;
	put_line ('return tmp ;') ;
	decrease_marging;
	put_line ('}') ;

	new_line(1) ;

	put_line ('void freeQueue (CP_QUEUE_NODE ** pqueue)') ;
	put_line ('{') ;
	increase_marging;
	put_line ('if (!(*pqueue)) return ;') ;
	new_line(1) ;
	put_line ('CP_QUEUE_NODE * tmp2, * tmp = *pqueue ;') ;
	new_line(1) ;
	put_line ('while (tmp->next)') ;
	put_line ('{') ;
	increase_marging;
	put_line ('tmp2 = tmp ;') ;
	put_line ('tmp = tmp->next ;') ;
	put_line ('free(tmp2) ;') ;
	decrease_marging;
	put_line ('}') ;
	decrease_marging;
	put_line ('}') ;

	new_line(1) ;
end;

syntactic_rule INIT_GLOBAL_LIST_COMM_PLACE is
begin
	put ('COMM_PLACE * cpArray[') ;
	put (to_string($#)) ;
	put_line ('] ;') ;

	apply HEAD_INIT_LIST_COMM_PLACE($0) ;
end;

syntactic_rule FREE_GLOBAL_LIST_COMM_PLACE is
begin
	put ('for (i = 0; i<') ;
	put (to_string($#)) ;
	put_line ('; i++) {') ;

	increase_marging;
	put_line ('freeQueue (&cpArray[i]->queue) ;') ;
	put_line ('free (cpArray[i]) ;') ;
	decrease_marging;

	put_line ('}') ;

	new_line (1) ;
end;

syntactic_rule HEAD_ENUM_COMM_PLACE is
begin
	if $# > 0 then

		put ('__') ;
		put_upper ($STR(1));

		if $# > 1 then
			put (',') ;

			apply HEAD_ENUM_COMM_PLACE ($2*);
		end if;

	else
		put ('__NO_CP');
	end if;
end;

syntactic_rule HEAD_TAG_ENUM_COMM_PLACE is
begin
	if $# > 0 then

		put ('__') ;
		put_upper ($STR(1));
		put ('_GET,') ;

		put ('__') ;
		put_upper ($STR(1));
		put ('_PUT,') ;

		put ('__') ;
		put_upper ($STR(1));
		put ('_ANS') ;

		if $# > 1 then
			put (',') ;

			apply HEAD_TAG_ENUM_COMM_PLACE ($2*);
		end if;

	else
		put ('__NO_CP_TAG');
	end if;
end;

syntactic_rule HEAD_INIT_LIST_COMM_PLACE is
begin
	if $# > 0 then

		put ('cpArray[') ;
		put ('__') ;
		put_upper ($STR(1));
		put_line('] = (COMM_PLACE *) malloc(sizeof(COMM_PLACE)) ;') ;

		put ('cpArray[') ;
		put ('__') ;
		put_upper ($STR(1));
		put (']->count = ') ;
		put (to_string($int(1))) ;
		put_line (' ;') ;

		put ('cpArray[') ;
		put ('__') ;
		put_upper ($STR(1));
		put_line(']->queue = NULL ;') ;

		if $# > 1 then
			new_line(1) ;

			apply HEAD_INIT_LIST_COMM_PLACE ($2*);
		end if;

	end if;
end;

syntactic_rule INIT_LIST_COMM_PLACE is
begin

	put_line ('void commPlaceMngr (int my_rank, int nb_proc)') ;
	put_line ('{') ;
	increase_marging;

	put_line ('MPI_Status status;');
	put_line ('int i;');

	apply INIT_GLOBAL_LIST_COMM_PLACE ($0) ;
	new_line(1);

	put_line('printf(" My rank is %d and I am the communication places manager\n",my_rank);');
	new_line(1);

	put_line ('while (1) {');
	increase_marging;

		put_line('int buf;');
		put_line('MPI_Recv(&buf,1,MPI_INT,MPI_ANY_SOURCE,MPI_ANY_TAG,MPI_COMM_WORLD,&status);');

		new_line(1);

		put_line('if (status.MPI_SOURCE == PROTO_MANAGER) break ;') ;

		new_line(1);
		put_line('switch (status.MPI_TAG) {') ;

			increase_marging;

			if $# > 0 then
				apply INTERNAL_LIST_COMM_PLACE ($0);
			end if;

			decrease_marging;

		new_line(1);
		put_line('}') ;

	decrease_marging;
	put_line('}');

	apply FREE_GLOBAL_LIST_COMM_PLACE ($0) ;

	decrease_marging;
	put_line('}');

end ;

syntactic_rule LIST_COMM_PLACE is
begin
    put_line('//Communication places manager');
    put ('//There are ');
    put ($STR_INT (0));
    put_line (' communication places');
    put_line('if (my_rank == COMMP_MANAGER) {');
    increase_marging;
    put_line('commPlaceMngr(my_rank, nb_proc);');
    decrease_marging;
    put_line('}');
    new_line(2);
end;

syntactic_rule INTERNAL_LIST_COMM_PLACE is
begin
    apply COMM_PLACES ($1);
    if $# > 1 then
        apply INTERNAL_LIST_COMM_PLACE ($2*);
    end if;
end;


syntactic_rule COMM_PLACES is
begin
    put ('//Communication place ');
    put ($STR(0));
    new_line(1);

	put('case __') ;
    put_upper ($STR(0));
    put_line ('_GET:') ;
    increase_marging;

    put ('if ((cpArray[__') ;
    put_upper ($STR(0));
    put_line (']->count - buf) >= 0) {');
    increase_marging;
    put ('cpArray[__') ;
    put_upper ($STR(0));
    put_line (']->count -= buf ;') ;

    put ('MPI_Send(&buf, 1, MPI_INT, status.MPI_SOURCE, ') ;
	put ('__') ;
    put_upper ($STR(0));
	put_line ('_ANS, MPI_COMM_WORLD) ;') ;

    decrease_marging;
    put_line ('} else {') ;
    increase_marging;
    put ('appendToQueue(') ;
    put ('&cpArray[__') ;
    put_upper ($STR(0));
    put_line (']->queue, status.MPI_SOURCE, buf) ;') ;
    decrease_marging;
    put_line ('}') ;
    put_line ('break ;') ;
    new_line(1);

	decrease_marging;

	put('case __') ;
    put_upper ($STR(0));
    put_line ('_PUT:') ;
    increase_marging;

    put ('cpArray[__') ;
    put_upper ($STR(0));
    put_line (']->count += buf ;') ;

    put ('if (cpArray[__') ;
    put_upper ($STR(0));
    put (']->queue->next && ') ;
	put ('(cpArray[__') ;
    put_upper ($STR(0));
    put_line (']->queue->next->nbToken - buf >= 0)) {') ;

    increase_marging;

    put ('CP_QUEUE_NODE * tmpNode = popFromQueue(') ;
    put ('&cpArray[__') ;
    put_upper ($STR(0));
    put_line (']->queue);') ;

    put ('cpArray[__') ;
    put_upper ($STR(0));
    put_line (']->count -= tmpNode->nbToken ;') ;

    put ('MPI_Send(&buf, 1, MPI_INT, tmpNode->rank, ') ;
	put ('__') ;
    put_upper ($STR(0));
	put_line ('_ANS, MPI_COMM_WORLD) ;') ;

    put_line ('free (tmpNode) ;') ;
    decrease_marging;
	put_line ('}') ;

    put_line ('break ;') ;
    new_line(1);

    decrease_marging;
    new_line(1);
end;

syntactic_rule ONE_COMM_PLACE_PROC_IN is
begin
    put ('//');
    put ($STR(1));
    new_line(1);
    put_line('MPI_Iprobe(MPI_ANY_SOURCE,TAG_COMMP_PUT,MPI_COMM_WORLD,&flag,&status);');
    put_line('if (flag) {');
    increase_marging;
    put_line('int buf, source = status.MPI_SOURCE;');
    put_line('MPI_Recv(&buf,1,MPI_INT,source,TAG_COMMP_PUT,MPI_COMM_WORLD,&status);');
    put_line('cmp++;');
    put_line('printf("My rank is %d and I received a new token in one of my communication places, the new value is %d.\n", my_rank, cmp);');
    decrease_marging;
    put_line('}');
    new_line(1);

    if $# > 1 then
        apply ONE_COMM_PLACE_PROC_IN ($2*);
    end if;
end;


//WARNING:  This works if only one communication place
syntactic_rule ONE_COMM_PLACE_PROC_OUT is
begin
    put ('//');
    put ($STR(1));
    new_line(1);
    put_line('MPI_Iprobe(MPI_ANY_SOURCE,TAG_COMMP_GET,MPI_COMM_WORLD,&flag,&status);');
    put_line('if (flag && cmp > 0) {');
    increase_marging;
    put_line('int buf, source = status.MPI_SOURCE;');
    put_line('MPI_Recv(&buf,1,MPI_INT,source,TAG_COMMP_GET,MPI_COMM_WORLD,&status);');
    put_line('MPI_Ssend(&buf,1,MPI_INT,source,TAG_COMMP_GET,MPI_COMM_WORLD);');
    put_line('cmp--;');
    put_line('printf("My rank is %d and I sent a token from one of my communication places, the new value is %d.\n", my_rank, cmp);');
    decrease_marging;
    put_line('}');
    new_line(1);

    if $# > 1 then
        apply ONE_COMM_PLACE_PROC_OUT ($2*);
    end if;
end;



//***************************************************
//******          PN-processes                 ******
//***************************************************



syntactic_rule LIST_PROCESS is
begin
    put ('//There are ');
    put ($STR_INT (0));
    put (' processes');
    new_line(1);

    //If more than zero PN-process
    if $# > 0 then

        //Creation of a string array to distribute the PN-process
        put ('enum PROCESSES_T {');
        increase_marging;
        apply HEAD_LIST_PROCESS ($0);
        decrease_marging;
        put ('};');
        new_line(2);

        //Apply sub-tree rule
        apply INTERNAL_LIST_PROCESS ($0);

        new_line(1);
    end if;
end;


//Internal header syntactic rule for PT-processes
syntactic_rule HEAD_LIST_PROCESS is
    begin

    //Creation of a string array with the name of each process
    put ('__');
    put_upper ($STR(1));
    if $# > 1 then
        put (',');
        apply HEAD_LIST_PROCESS ($2*);
    end if;
end;


//Internal body syntactic rule for PT-processes
syntactic_rule INTERNAL_LIST_PROCESS is
begin
    new_line(1);
    put ('//Process ');
    put_line ($STR(1));

    put ('void PNProc_');
    put ($STR(1));
    put_line('(int state, int my_rank, int nb_proc) {');
    increase_marging;

    new_line (1);
    put_line ('MPI_Request request;');
    put_line ('MPI_Status status;');
    new_line (1);

    //Printing process information
    put ('printf(" My rank is %d and I am ');
    put ($STR(1));
    put_line ('\n",my_rank);');
    new_line(1);

    //Main loop
    put_line ('int buf, rcvCount, flag;');

    put_line ('while (1) {');
    increase_marging;

    put_line('//Sleeping EXEC_STEP seconds');
    put_line('sleep(EXEC_STEP);');
    new_line(1);

    put_line('//Checking if Prototype manager request END');
    put_line('MPI_Iprobe(PROTO_MANAGER,TAG_END,MPI_COMM_WORLD,&flag,&status);');
    put_line('if (flag) {');
    increase_marging;
    put_line('int buf;');
    put_line('MPI_Recv(&buf,1,MPI_INT,PROTO_MANAGER,TAG_END,MPI_COMM_WORLD,&status);');
    put_line('break;');
    decrease_marging;
    put_line('}');
    new_line(1);

    apply PNPROCESS ($1);

    decrease_marging;
    put_line ('}');

    decrease_marging;
    put_line('}');
    new_line(1);

    if $# > 1 then
        apply INTERNAL_LIST_PROCESS ($2*);
    end if;
end;


syntactic_rule PNPROCESS is
begin
    new_line(1);
    put('//');
    put($STR(2));
    new_line(1);

    put_line('//Main switch');
    put_line ('switch(state) {');
    increase_marging;

    apply LOCAL_PLACE ($1);
    apply LOCAL_TRANS ($2);
    apply LOC_SYNC_TRANSITION ($3);

    new_line(1);
    put_line ('//Default');
    put_line ('default: break;');
    decrease_marging;
    put_line ('}');
end;



//***************************************************
//******       PN-processes : Transitions      ******
//***************************************************



syntactic_rule LOCAL_TRANSITIONS is
begin
    put('__') ;
    put_upper($STR(1));
    if $# > 1 then
	put(',');
    	apply LOCAL_TRANSITIONS ($2*);
    end if;
end;


syntactic_rule LOCAL_TRANS is
begin
    new_line(1);
    put('//Transition ');
    put ($STR(1));
    new_line(1);

    put('case ');
    put ('__') ;
    put_upper ($STR(1));
    put (' : ');
    new_line(1);

    apply LOC_TRANS_OUT ($1);

    if $# > 1 then
        apply LOCAL_TRANS ($2*);
    end if;
end;


syntactic_rule LOC_TRANS_OUT is
begin
    increase_marging;

    apply COMM_TRANS_IN ($1);
    apply COMM_TRANS_OUT ($2);

    put_line('//Going to next place...');
    put('state = ');
    apply INTERNAL_LOC_TRANS_OUT ($3);
    put (';');
    new_line(1);

    put('printf("My rank is %d and I am firing the ');
    put ($STR(0));
    put (' transition.",my_rank);');
    new_line(1);
    put_line ('printf("\n");');
    put_line('break;');
    decrease_marging;
end;


syntactic_rule COMM_TRANS_IN is
begin
	put('//IN arcs from communication places');
	if $# > 0 then

		apply INTERNAL_COMM_TRANS_IN ($1);

		put ('rcvCount = ') ;
		put (to_string($#)) ;
		put_line (';') ;

		new_line(1);

		put_line ('while (1)') ;
		put_line ('{');
		increase_marging;

		put_line ('//Blocking wait for a message');
		put_line ('MPI_Recv(&buf, 1, MPI_INT, MPI_ANY_SOURCE, MPI_ANY_TAG, MPI_COMM_WORLD, &status) ;');
		new_line(1);

		put_line ('//If END request from prototype manager');
		put_line ('if (status.MPI_SOURCE == PROTO_MANAGER)');
		increase_marging;
		put_line('return ;') ;
		decrease_marging;
		new_line(1);

		put_line ('//If answer from communication places manager');
		put_line ('if (status.MPI_SOURCE == COMMP_MANAGER) {');
		increase_marging;

		put_line('if (--rcvCount == 0) break ;') ;

		decrease_marging;
		put_line ('}');

		decrease_marging;
		put_line ('}');

		new_line(1);

	end if;
end;

syntactic_rule INTERNAL_COMM_TRANS_IN is
begin
    put('//Arc from communication place ');
    put ($STR(0));
    new_line(1);

    put ('buf = ');
    put (to_string($INT(0))) ;
    put_line (';') ;

    put ('MPI_Send(&buf,1,MPI_INT,COMMP_MANAGER,') ;
    put ('__') ;
    put_upper ($STR(0));
	put_line ('_GET ,MPI_COMM_WORLD);');

    if $# > 0 then
        apply INTERNAL_COMM_TRANS_IN ($2*);
    end if;
    new_line(1);
end;

syntactic_rule COMM_TRANS_OUT is
begin
    put_line ('//Out arcs to communication places');
    if $# > 0 then
        apply INTERNAL_COMM_TRANS_OUT ($1);
    end if;
    new_line(1);
end;


syntactic_rule INTERNAL_COMM_TRANS_OUT is
begin
    put ('//Arc to communication place ');
    put ($STR(0));
    new_line(1);

    put ('buf = ');
    put (to_string($INT(0))) ;
    put_line (';') ;

    put ('MPI_Isend(&buf,1,MPI_INT,COMMP_MANAGER,') ;
    put ('__') ;
    put_upper ($STR(0));
	put_line ('_PUT ,MPI_COMM_WORLD,&request);');

    if $# > 1 then
        apply INTERNAL_COMM_TRANS_OUT ($2*);
    end if;
    new_line(1);
end;


syntactic_rule INTERNAL_LOC_TRANS_OUT is
begin
    put ('__') ;
    put_upper ($STR(1));
end;



//***************************************************
//******       PN-processes : Places           ******
//***************************************************



syntactic_rule LOCAL_PLACES is
begin
    put('__');
    put_upper($STR(1));
    if $# > 1 then
        put(',');
        apply LOCAL_PLACES ($2*);
    end if;
end;


syntactic_rule LOCAL_PLACE is
begin
    new_line(1);
    put('//Place ');
    put ($STR(1));
    new_line(1);

    put('case ');
    put ('__') ;
    put_upper ($STR(1));
    put (' : ');
    new_line(1);

    increase_marging;
    put ('printf("My rank is %d and my state is ');
    put ($STR(1));
    put ('.\n", my_rank);');
    new_line(1);
    put_line('//Going to next transition');
    put('state = ');
    apply LOC_PLACE_OUT ($1);
    put (';');
    new_line(1);

    put_line('break;');
    decrease_marging;

    if $# > 1 then
        apply LOCAL_PLACE ($2*);
    end if;
end;


syntactic_rule LOC_PLACE_OUT is
begin
    apply INTERNAL_LOC_PLACE_OUT ($3);
    apply INTERNAL_ST_LOC_PLACE_OUT ($2) ;
end;

syntactic_rule INTERNAL_LOC_PLACE_OUT is
begin
	if $# > 0 then
		put ('__') ;
		put_upper ($STR(1));
    end if;
end;

syntactic_rule INTERNAL_ST_LOC_PLACE_OUT is
begin
	if $# > 0 then
		put ('__') ;
		put_upper ($STR(1));
    end if;
end;



//***************************************************
//******    PN-processes : Synch. transitions  ******
//***************************************************



syntactic_rule ONE_SYNC_TRANS_PROC_OUT is
begin
    put('__');
    put_upper($STR(1));
end;


syntactic_rule LOC_SYNC_TRANSITIONS is
begin
    apply ONE_SYNC_TRANS_PROC_OUT ($1);
end;


syntactic_rule LOC_SYNC_TRANSITION is
begin
    if $# > 0 then
        new_line(1);
        put('//Synchronization transition ');
        put ($STR(1));
        new_line(1);

        put('case ');
        put ('__') ;
        put_upper ($STR(1));
        put (' : ');
        new_line(1);

        increase_marging;

        put ('buf = __') ;
        put_upper($STR(1));
        put (';') ;
	new_line(1);
        put('MPI_Send(&buf,1,MPI_INT,SYNCT_MANAGER,TAG_SYNCT_ASK,MPI_COMM_WORLD);');
	new_line(1);

	put_line ('//Blocking wait for a message');
	put_line ('MPI_Recv(&buf, 1, MPI_INT, MPI_ANY_SOURCE, MPI_ANY_TAG, MPI_COMM_WORLD, &status) ;');
	new_line(1);

	put_line ('//If END request from prototype manager');
	put_line ('if (status.MPI_SOURCE == PROTO_MANAGER)');
	increase_marging;
	put_line('return ;') ;
	decrease_marging;
	new_line(1);

	put_line ('//If answer from communication places manager');
	put_line ('if (status.MPI_SOURCE == SYNCT_MANAGER && status.MPI_TAG == TAG_SYNCT_ACK) {');
	increase_marging;

        put ('printf("My rank is %d and I am firing the synchronized transition ');
        put ($STR(1));
        put ('.\n", my_rank);');
        new_line(1);
        put_line('//Going to next place');
        put('state = ');
        apply LOC_SYNC_TRANSITIONS ($1);
        put (';');
        new_line(1);

        put_line('break;');
        decrease_marging;

	decrease_marging;
	put_line ('}');


        if $# > 1 then
            apply LOC_SYNC_TRANSITION ($2*);
        end if;
    end if;
end;






//***************************************************
//******       List of instances               ******
//***************************************************



syntactic_rule GLOBAL_LIST_INSTANCE is
begin
    put_line ('// Instances structure') ;
    put_line ('typedef struct INSTANCE {') ;
    increase_marging ;
    put_line ('void (*code)(int, int, int) ;') ;
    put_line ('int PNProcess ;') ;
    put_line ('int startState ;') ;
    decrease_marging ;
    put_line('} INSTANCE_T ;') ;

    put_line ('// Global instances array') ;
    put ('INSTANCE_T * instanceArray[') ;
    put (to_string($#)) ;
    put_line ('] ;') ;
end;

syntactic_rule GLOBAL_FREE_LIST_INSTANCE is
begin
	put_line ('// Free the global list instance array') ;
	put ('for (i = 0; i<') ;
	put (to_string($#)) ;
	put_line ('; i++)') ;
	increase_marging;
	put_line ('free(instanceArray[i]) ;') ;
	decrease_marging;
end;

syntactic_rule LIST_INSTANCE is
begin
    put_line ('int instIndex = 0 ;') ;
    apply INTERNAL_LIST_INSTANCE ($0);
end;

syntactic_rule INTERNAL_LIST_INSTANCE is
begin
    apply ($1) ;
    if $# > 1 then
        apply INTERNAL_LIST_INSTANCE ($2*);
    end if;
end;

syntactic_rule ONE_INSTANCE is
begin
    put_line ('instanceArray[instIndex] = (INSTANCE_T *) malloc(sizeof(INSTANCE_T)) ;') ;

    put ('instanceArray[instIndex]->code = &PNProc_') ;
    put ($STR(2)) ;
    put_line (' ;') ;

    put ('instanceArray[instIndex]->PNProcess = __') ;
    put_upper ($STR(2)) ;
    put_line (' ;') ;

    put ('instanceArray[instIndex++]->startState = __') ;
    put_upper ($STR(1)) ;
    put_line (' ;') ;
    new_line(1);
end;






//***************************************************
//******       Functions to do...              ******
//***************************************************


syntactic_rule LIST_BELONG is
begin
   new_line (1);
end;

syntactic_rule LIST_ARC is
begin
   new_line (1);
end;

syntactic_rule LIST_COMM_ARC is
begin
   new_line (1);
end;

syntactic_rule ONE_BELONG is
begin
   new_line (1);
end;

syntactic_rule ONE_ARC is
begin
   new_line (1);
end;

syntactic_rule ONE_COMM_ARC is
begin
   new_line (1);
end;

syntactic_rule OBJECT_NAME is
begin
   put ($STR(0));
end;

syntactic_rule PROC_OUT is
begin
    put ($STR(0));
end;

syntactic_rule PROC_IN is
begin
    put ($STR(0));
end;

syntactic_rule ONE_SYNC_TRANS_PROC_IN is
begin
    put ($STR(0));
end;

syntactic_rule LIST_STT_PLACE is
begin
    new_line (1);
end;

syntactic_rule INSTANCES is
begin
    put ($STR(0));
end;

syntactic_rule SYNC_TRANSITIONS is
begin
    put ($STR(0));
end;

syntactic_rule SYNC_TRANS_IN is
begin
    put ($STR(0));
end;

syntactic_rule SYNC_TRANS_OUT is
begin
    put ($STR(0));
end;

syntactic_rule COMM_PLACE_IN is
begin
    put ($STR(0));
end;

syntactic_rule COMM_PLACE_OUT is
begin
    put ($STR(0));
end;

syntactic_rule ST_LOC_PLACE_OUT is
begin
    put ($STR(0));
end;

syntactic_rule INTERNAL_PROCESS_TABLE is
begin
    put ($STR(0));
end;

