annex_file

//The main semantic rule
semantic_rule DO_THE_WORK (none) return void is
THE_TREE : semantic_tree;
begin

	//Creating the main tree
	THE_TREE := create_sm_tree ([C_MPI # # ]);

	//Creating the subtrees
	message ('Working on process...');
	THE_TREE := add_sm_son ($smt (THE_TREE), sm_rule WORK_ON_PROCESS ());
	message ('Working on synchronisation transitions...');
	THE_TREE := add_sm_son ($smt (THE_TREE), sm_rule WORK_ON_SYNC_TRANS ());
	message ('Working on communication places...');
	THE_TREE := add_sm_son ($smt (THE_TREE), sm_rule WORK_ON_COMM_PLACE ());

	//Generating the tree
	generate $smt (THE_TREE) in 'hello.c';
	message ('Done...');
	return;
end;

//The process semantic rule
semantic_rule WORK_ON_PROCESS (none) return semantic_tree is
RETV : semantic_tree;
begin
	//Creating the subtree
	RETV := create_sm_tree ([LIST_PROCESS # to_string (nb_node_instance (PROCESS)) #]);

	if nb_node_instance (PROCESS) > 0 then
		for PROCESS in 1 .. nb_node_instance (PROCESS) do

			//Getting the name and instance of each process
			RETV := add_sm_son ($smt (RETV),
								sm_rule CREATE_PROCESS (nodeID => $int (PROCESS))) ;
				//NAME => $atrv_str (attribute NAME from get_node_reference (PROCESS , $int (PROCESS))),
				//INSTANCES => $atrv_syt (attribute INSTANCES from get_node_reference (PROCESS , $int (PROCESS)))));
		end for;

	end if;

	return $smt (RETV);
end;

semantic_rule CREATE_PROCESS (nodeID : integer) return semantic_tree is
	RETV : semantic_tree;
	nameProc : string;
begin

	nameProc := $atrv_str (attribute NAME from get_node_reference (PROCESS, $int (nodeID)));

	//Creating the process subtree
	RETV := create_sm_tree ([PNPROCESS # $str(nameProc) #]);
	
	//Creating the three subtrees (instances, places, local transitions)
	RETV := add_sm_son ($smt (RETV), sm_rule CREATE_INSTANCES (nodeID => $int (nodeID))) ;
	//RETV := add_sm_son ($smt (RETV), sm_rule CREATE_PLACES (nodeID => $int (nodeID))) ;
	//RETV := add_sm_son ($smt (RETV), sm_rule CREATE_LOCTRANS (nodeID => $int (nodeID))) ;
	
	return $smt (RETV);
end;

semantic_rule CREATE_INSTANCES (nodeID : integer) return semantic_tree is
	RETV : semantic_tree;
	nameProc : string;
	syInstances : syntactic_tree;
begin
	syInstances := $atrv_syt (attribute INSTANCES from get_node_reference (PROCESS, $int (nodeID)));
	
	//Creating the subtree
	RETV := create_sm_tree ([INSTANCES # $str(nameProc) # number_of_sy_son($syt(syInstances))]);
	
	//Creating the subtree : instance1 .. instanceN
	for INS in 1 .. number_of_sy_son ($syt(syInstances)) do
	
		message ({ '-> Instance starting in : ' & $str_sy_node($sy_son(1, $sy_son($int(INS), $syt(syInstances)))) }) ;
	
		RETV := add_sm_son ($smt (RETV),
							sm_tree ONE_INSTANCE (START_PLACE => $str_sy_node(
																	$sy_son(1,
																		$sy_son($int(INS),
																				$syt(syInstances))
																	)
																)
												));
	end for;
	
	return $smt (RETV);
end;

//The synchronisation transitions rule
semantic_rule WORK_ON_SYNC_TRANS (none) return semantic_tree is
RETV : semantic_tree;
begin

	//Creating the root subtree indicating number of Synchronised Transitions
	RETV := create_sm_tree ([LIST_SYNC_TRANS # to_string (nb_node_instance (SYNC_TRANS))#]);

	//If at least one Synchronised Transition
	if nb_node_instance (SYNC_TRANS) > 0 then
		for ST in 1 .. nb_node_instance (SYNC_TRANS) do

			//Getting the name of each synchronisation transition
			RETV := add_sm_son ($smt (RETV),
								sm_rule CREATE_SYNC_TRANS (nodeID => $int (ST)));
			
		end for;

	end if;

	return $smt (RETV);
end;

semantic_rule CREATE_SYNC_TRANS (nodeID : integer) return semantic_tree is
	RETV : semantic_tree;
	P_IN : semantic_tree;
	P_OUT : semantic_tree;
	nameIN : string;
	nameOUT : string;
	nameTrans : string;
	namePL : string;
	processName : string;
begin
	nameTrans := $atrv_str (attribute NAME from get_node_reference (SYNC_TRANS, $int (nodeID)));

	RETV := create_sm_tree ([SYNC_TRANSITIONS # $str (nameTrans) # ]);
	P_IN := create_sm_tree ([PROC_IN # 'PROCIN' #]);
	P_OUT := create_sm_tree ([PROC_OUT # 'PROCOUT' #]);
	
	message({'* SyncTrans Name : ' & $str (nameTrans)}) ;
	
	if nb_node_instance (ARC) > 0 then
	
		for AR in 1 .. nb_node_instance (ARC) do
		
			nameIN := $atrv_str (attribute NAME from get_neighbour_in (get_link_reference(ARC,$int (AR)), 1));
			nameOUT := $atrv_str (attribute NAME from get_neighbour_out (get_link_reference(ARC,$int (AR)), 1));
			
			message({'* ARC nb' & to_string($int(AR))}) ;
			message({{$str(nameIN) & ' -> ' } & $str(nameOUT)}) ;
			
			if $str (nameIN) = $str (nameTrans) then

				message('ST ---> PL') ;
	
				//		AR
				//  ST ---> PL
	
				if nb_node_instance (BELONG) > 0 then
					for GROUP in 1 .. nb_node_instance (BELONG) do
						
						message({'1-Group : ' & to_string($int(GROUP))}) ;
						
						if nb_neighbour_having_class (get_link_reference(BELONG,$int (GROUP)), STT_PLACE) > 0 then
							for PL in 1 .. nb_neighbour_having_class (get_link_reference(BELONG,$int (GROUP)), STT_PLACE) do
								namePL := $atrv_str (attribute NAME from get_neighbour_having_class(get_link_reference(BELONG, $int (GROUP)), $int(PL), STT_PLACE));
								
								//Est ce que la place du BELONG est reliee a la transition ?
								if $str (namePL) = $str (nameOUT) then
									
									processName := $atrv_str (attribute NAME from get_neighbour_having_class(get_link_reference(BELONG, $int (GROUP)), 1, PROCESS));
									P_OUT := add_sm_son ($smt (P_OUT),
														sm_tree ONE_SYNC_TRANS_PROC_OUT(NAME => $str (processName),
																						TARGET_PLACE => $str (namePL)));
										
									message({'namePL (OUT) : ' & $str(namePL)}) ;
									message({'1-Found namePL process name is : ' & $str(processName)}) ;
								end if;
							end for;
						end if;
					end for;
				end if;

			elsif $str (nameOUT) = $str (nameTrans) then
			
				message('PL ---> ST') ;
				
				//		AR
				//  PL ---> ST

				if nb_node_instance (BELONG) > 0 then
					for GROUP in 1 .. nb_node_instance (BELONG) do
					
						message({'2 - Group : ' & to_string($int(GROUP))}) ;
					
						if nb_neighbour_having_class (get_link_reference(BELONG,$int (GROUP)), STT_PLACE) > 0 then
							for PL in 1 .. nb_neighbour_having_class (get_link_reference(BELONG,$int (GROUP)), STT_PLACE) do
							
								namePL := $atrv_str (attribute NAME from get_neighbour_having_class(get_link_reference(BELONG, $int (GROUP)), $int (PL), STT_PLACE));
								
								if $str (namePL) = $str (nameIN) then
									message({'namePL (IN) : ' & $str(namePL)}) ;
								
									processName := $atrv_str (attribute NAME from get_neighbour_having_class(get_link_reference(BELONG, $int (GROUP)), 1, PROCESS));
									P_IN := add_sm_son ($smt (P_IN),
														sm_tree ONE_SYNC_TRANS_PROC_IN(NAME => $str (processName),
														SOURCE_PLACE => $str (namePL)));
									message({'Found namePL process name is : ' & $str(processName)}) ;
								end if;
							end for;
						end if;
					end for;
				end if;
			end if;

		end for;
	end if;

	RETV := add_sm_son ($smt (RETV), $smt (P_IN));
	RETV := add_sm_son ($smt (RETV), $smt (P_OUT));

	return $smt (RETV);
end;

//The communication places rule
semantic_rule WORK_ON_COMM_PLACE (none) return semantic_tree is
RETV : semantic_tree;
begin

	//Creating the root subtree indicating number of Communication Places
	RETV := create_sm_tree ([LIST_COMM_PLACE # to_string (nb_node_instance (COMM_PLACE))#]);

	//If at least one Synchronised Transition
	if nb_node_instance (COMM_PLACE) > 0 then
		for CP in 1 .. nb_node_instance (COMM_PLACE) do

			//Applying CREATE_COMM_PLACE rule on each communication place
			RETV := add_sm_son ($smt (RETV),
								sm_rule CREATE_COMM_PLACE (nodeID => $int (CP)));
			
		end for;

	end if;

	return $smt (RETV);
end;

semantic_rule CREATE_COMM_PLACE (nodeID : integer) return semantic_tree is
	RETV : semantic_tree;
	P_IN : semantic_tree;
	P_OUT : semantic_tree;
	nameIN : string;
	nameOUT : string;
	namePlace : string;
	nbTokenPlace : integer;
	nameLT : string;
	processName : string;
begin
	namePlace := $atrv_str (attribute NAME from get_node_reference (COMM_PLACE, $int (nodeID)));
	nbTokenPlace := $atrv_int (attribute NB_IN_TOKENS from get_node_reference (COMM_PLACE , $int (nodeID)));

	RETV := create_sm_tree ([COMM_PLACES # $str (namePlace) # $int (nbTokenPlace)]);
	P_IN := create_sm_tree ([PROC_IN # 'PROCIN' #]);
	P_OUT := create_sm_tree ([PROC_OUT # 'PROCOUT' #]);
	
	message({'* Name Place : ' & $str (namePlace)}) ;
	
	if nb_node_instance (COMM_ARC) > 0 then
	
		for CA in 1 .. nb_node_instance (COMM_ARC) do
		
			nameIN := $atrv_str (attribute NAME from get_neighbour_in (get_link_reference(COMM_ARC,$int (CA)), 1));
			nameOUT := $atrv_str (attribute NAME from get_neighbour_out (get_link_reference(COMM_ARC,$int (CA)), 1));
			
			message({'* CommArc nb' & to_string($int(CA))}) ;
			message({{$str(nameIN) & ' -> ' } & $str(nameOUT)}) ;
			
			if $str (nameIN) = $str (namePlace) then

				//		CA
				//  CP ---> LT

				if nb_node_instance (BELONG) > 0 then
					for GROUP in 1 .. nb_node_instance (BELONG) do
					
						message({'1-Group : ' & to_string($int(GROUP))}) ;
					
						if nb_neighbour_having_class (get_link_reference(BELONG,$int (GROUP)), LOC_TRANS) > 0 then
							for LT in 1 .. nb_neighbour_having_class (get_link_reference(BELONG,$int (GROUP)), LOC_TRANS) do
								nameLT := $atrv_str (attribute NAME from get_neighbour_having_class(get_link_reference(BELONG, $int (GROUP)), $int(LT), LOC_TRANS));
								
								//Est ce que la place du BELONG est reliee a la transition ?
								if $str (nameLT) = $str (nameOUT) then
								
									processName := $atrv_str (attribute NAME from get_neighbour_having_class(get_link_reference(BELONG, $int (GROUP)), 1, PROCESS));
									P_OUT := add_sm_son ($smt (P_OUT),
														sm_tree ONE_COMM_PLACE_PROC_OUT(NAME => $str (processName),
																						TARGET_TRANS => $str (nameLT)));
									
									message({'NameLT (OUT) : ' & $str(nameLT)}) ;
									message({'1-Found NameLT process name is : ' & $str(processName)}) ;
								end if;
							end for;
						end if;
					end for;
				end if;

			elsif $str (nameOUT) = $str (namePlace) then
			
				//		CA
				//  LT ---> CP

				if nb_node_instance (BELONG) > 0 then
					for GROUP in 1 .. nb_node_instance (BELONG) do
					
						message({'2 - Group : ' & to_string($int(GROUP))}) ;
					
						if nb_neighbour_having_class (get_link_reference(BELONG,$int (GROUP)), LOC_TRANS) > 0 then
							for LT in 1 .. nb_neighbour_having_class (get_link_reference(BELONG,$int (GROUP)), LOC_TRANS) do
							
								nameLT := $atrv_str (attribute NAME from get_neighbour_having_class(get_link_reference(BELONG, $int (GROUP)), $int (LT), LOC_TRANS));
								
								if $str (nameLT) = $str (nameIN) then
								
									message({'NameLT (IN) : ' & $str(nameLT)}) ;
								
									processName := $atrv_str (attribute NAME from get_neighbour_having_class(get_link_reference(BELONG, $int (GROUP)), 1, PROCESS));
									P_IN := add_sm_son ($smt (P_IN),
														sm_tree ONE_COMM_PLACE_PROC_IN(NAME => $str (processName),
																						SOURCE_TRANS => $str (nameLT)));
									message({'Found NameLT process name is : ' & $str(processName)}) ;
								end if;
							end for;
						end if;
					end for;
				end if;
			end if;

		end for;
	end if;

	RETV := add_sm_son ($smt (RETV), $smt (P_IN));
	RETV := add_sm_son ($smt (RETV), $smt (P_OUT));

	return $smt (RETV);
end;
