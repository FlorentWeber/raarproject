
Runtime Chapter

   The file rutime.c contains functions to ensure that the project will
work.

   First, this file have some functions that will print the different states of the execution. We also have put some functions to generate a dot file so that we can have a view of it.

   The other things that the runtime implement, is some functions that manageshe choice of the processes. Indeed, the choice is random and depends on the queue that is manage by the process manager. This section is clearly explain in a chapter of this report.

   To manage the queue, we compare the table of the actual queue that contains the token, with the table of the require tokens. We take the maximum value in the first table and we multiply by the size of the first one. We give priority to tables which have fill different entries. We suppose that the most difficult state to have, is to get at least one token for each different transitions.

   In order to fill this condition, we take the value that we have found before and we add it with the number of tokens that we have. So we can determinate the importance of the table.

   The higher value we have, the more important priority it is.

   The runtime is not a file generated by the code generator. Indeed, in order to clear the msst file from functions that not depend on the model's tree, we put them aside to only generate functions that really depend on the tree of the model.


MAKEFILE, THE STRUCTURE OF THE PROJECT AND SCRIPTS Chapter

THE MAKEFILE part


   First, in order to be able to build the project, we must put the path of metascribe in CONTAINER_TDIR and we need to use the gnat that we can find in ocarina polyorb.

   The first rule that the Makefile must run, is 'generate'. This rules will use superclean and after, will check if the directory JDT exists and if it have msm files in it.
 
   If it pass the check, it will run rules-generator and tengine-generator which will compile and create the binary files of the code generator.
 
  To launch the generation of the MPI source, we will use the rule test-pour-fk. The protocol that we have to follow, is that we must put the name of the msm without -main.msm. So in order to execute the test, we must write : 

    make test-pour-fk NAME=<NAME>,

where <NAME> is the name of the file without -main.msm. The rule will automatically search into the JDT directory and check with the script check.sh if the file exists. After, if it pass the test, it will generate a source, a header and a script.

    The script check.sh will execute the script generated by the generator : test-generator.sh. This script contains the number of node that we have to run. Indeed, the only way to know the number of nodes or processes that we have to generate, is into the code generated by the generator. We can also generate the bhost file with this number.

   So with the number of nodes, we can call the test-generator of the Makefile with : 

   make test-generator NAME=<NAME> NUM=NB_NODES. 

This rules will compile the source into a binary and launch mpirun with the right argument. The execution is automatically done by the script test-generator.sh

   We also had created a rule to generate a .dot file : 
 
   make dot NAME=<NAME>


STRUCTURE OF THE PROJECT part


    The project will be organize into many directory. In order to have a clear view of the file, we will put all the msm file into the directory JDT. In JDT directory, we will have a directory called image where we put all the picture of our petri net. In the directory called Coloane, we will put all the file .model that contains models of the petri net that we had created.

   To not fill the main directory by source and object files, we move all the adb, ads, o and ali files into the directory generator.

   For the source generated, we put it in src directory, the header in include, the object files in obj and binary in bin. If we generate the dot file, we put it in the dot directory.

   We choose to not generate the runtime codes with metascribe because they don't depend on parameters like the number of processes... . So we put them in the runtime directory with his header.

   So files, that we are not generated, are : the runtime, the Makefile, the msm, msf, msst and mssm files, the script check.sh and all the files for the reports.
 
   We also had created a ModelParser in order to generate a msm file from a model file created by Coloane.


THE SCRIPTS part


   In the project, we will use 2 scripts. One that is done by us and the other one will be generate by the code generator.
  
   For the first one, the script will create directory if they don't exists and  check if there are msm files in JDT directory. If not, it will send an error message and ask the user to create msm files and to put them in the JDT directory.
This script will also call the code generator if we give it 2 arguments : One is the name of the file, and the other is the kind of the execution.

Indeed, in order to run the project, we will have to call the code generator with the right msm file. If the file doesn't exist, we must send an error message and invite the user to use a existing msm file.

After the file is check, we can call the code generator and call the script that is generated.

   So, the second script is generated by the code generator. We have the name of the file, however, we don't know how many processes we will have to run. 
 The code generator will generate a script that know how many nodes we needs. So for the bhost, if the number of ip adress or host names are lower than the number of nodes required, the script will erase and put the localhost with a number of cpu that represents the number of cpu we need.

   So the script will execute the test-generator rule of the makefile with the name et the number of nodes as arguments. So the makefile will launch lam, the compilation of the right file and run with mpirun with the right number of nodes.


THE BHOST chapter


   The bhost file is generated by the generated script : test-generator.sh. We cannot put the ip adress or host names  that we need to run the project. So the location of the different processes must be defined by the user.

   The Bhost contains the number of cpus which is in reality the number of nodes that we need to run the project. 

   In the beginning, we thought about regrouping the processes that need a lot of communication. 
Indeed, if these communication were done in a computer, we will gain a lot of time. In order to do that, we were thinking about using the argument cpu after the ip adress or host name. 
This argument will make the following rank to execute in the same location. With this, we can put the process in an order that make that we can produce the scenario that we want. 
But due to a lack of time, we only put the local adress and the number of nodes in the cpu argument and let the user fill as it want with the right number of nodes.

